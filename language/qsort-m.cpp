/*
 * Implement quick sort algorithm in C++, with multi-threads.
 *
 * This program is a exercise of multi-threading features of C++11,
 * including:
 *	future/async
 *	mutex/condition_variable
 * Producer/Consumer pattern is used in this program.
 *
 * A brief description of quick sort like this:
 *   1. for a given range, find an element as pivot, then move all elements
 *      that are smaller than the pivot before it, and all elements that
 *      are larger after it.
 *   2. for the smaller sub-range and the larger sub-range, repeat step 1
 *      until the sub-range has 0 or 1 element.
 *
 * For basic iteration (i.e. step 1), it is not a good idea to apply multi-
 * threading because the lock/switch cost is much bigger than compare/swap
 * itself; However, one basic iteration in a given range is irrelavent to
 * each other if ranges are not overlapped. Such a recursive process is a
 * good candidate of multi-threading process.
 *
 * Implementation note:
 *   Practice shows that threading cost is still too much if the granity
 *   goes too small. So if the sub-range is small enough, we process it
 *   inside the thread instead of forking a new thread task. See details
 *   in the note of QuickSort::worker().
 *
 *
 * Test platform:
 *   Debian 7.4 (64-bit) in VirtualBox 4GB mem, i5-2400S@2.5GHz x3
 *   vbox host iMac 21.5inc Mid 2011 i5@2.5GHz 12GB mem 1333 DDR3
 *   Lion 10.7.5
 *
 * Shuffled sequence data are generated by shuffle.py.
 *
 * ./qsort-m r5m.txt       # 5,000,000 shuffled data
 * load: 0.482
 *     5000000 items
 * duplicate: 0.008
 * qsort: 0.389
 * validate: 0.004
 * std::sort: 0.412
 * 
 */

#include <exception>
#include <iostream>
#include <fstream>
#include <iterator>
#include <vector>
#include <queue>
#include <algorithm>
#include <chrono>

#include <future>
#include <mutex>
#include <condition_variable>


using namespace std;
typedef vector<int> V;

namespace codex {
    template <typename T>
    class QuickSort {
	public:
	    QuickSort(T& data) : data_(data), task_in_progress(0) {}
	    virtual void run(unsigned workers = 4);

	protected:
	    typedef typename T::iterator Iterator;

	    // can be replaced with pair<>, used as a demonstration
	    // of nested class
	    class Task {
		public:
		    Task() { }
		    Task(Iterator begin, Iterator end)
			: begin(begin), end(end) {}
		    Task(const Task& t) : begin(t.begin), end(t.end) {}

		    Iterator begin, end;
	    };


	    Iterator pivot(Iterator begin, Iterator end);
	    void sort(Iterator begin, Iterator end);
	    int worker(void);

	protected:
	    T&			data_;
	    int 		task_in_progress;
	    queue<Task> 	tasks;
	    mutex		pmutex;
	    condition_variable 	cv;

	    const unsigned DefaultElementsPerSegment = 10000;
    };




    // a single sort iteration:
    // choose any number as pivot (in this example, we choose the middle
    // item in the subset) and put all items that are smaller than
    // the pivot before the pivot and all items that are larger than
    // the pivot after it.
    // the pivot iterator is returned.

    template <typename T>
    typename QuickSort<T>::Iterator QuickSort<T>::pivot(Iterator begin, Iterator end)
    {
	// choose any number in the subset as pivot, in this example,
	// we choose the item in the middle of the subset
        auto m = begin + (end - begin)/2;
        auto last = --end;
        auto pivot = *m;
        if (last - m > 0)
            swap(*m, *last);
    
        m = begin;
        for (auto i = begin; i != last; ++i) {
            if (*i < pivot) {
                swap(*i, *m);
                ++m;
            }
        }
        swap(*m, *last);
	return m;
    }

    template <typename T>
    void QuickSort<T>::run(unsigned workers)
    {
	if (data_.size() <= 1)		// nothing to do
	    return;

	if (workers <= 1) {		// let one thread do everything
	    sort(data_.begin(), data_.end());
	    return;
	}

	task_in_progress = 0;
	tasks.push(Task(data_.begin(), data_.end()));
	vector<future<int>> result;
	for (int i = 0; i < workers - 1; ++i) {
	    result.push_back(std::async(launch::async,
			&QuickSort<T>::worker, this));
	}
	worker();		// this thread itself is a worker
	int r = 0;
	for (future<int> &i : result) {
	    r += i.get();
	}
    }

    // entrance of worker thread

    template <typename T>
    int QuickSort<T>::worker(void)
    {
	while (true) {
	    QuickSort<T>::Task t;
	    {
		unique_lock<mutex> ul(pmutex);
		if (tasks.empty()) {
		    if (!task_in_progress)
			break;			// finish!
		    else {
			// other thread might generate new subset
			cv.wait(ul);
		    }
		    continue;
		} else {
		    t = tasks.front();
		    tasks.pop();
		    task_in_progress++;
		}
	    }

	    // this is a single iteration of qsort algorithm
	    // it takes some time to finish
	    typename QuickSort<T>::Iterator m = pivot(t.begin, t.end);

	    {
		unique_lock<mutex> ul(pmutex);
		bool more_task = false;

		// implementation note:
		// to avoid too small granity (thus too high threading cost)
		// generate new task only when the range is bigger
		// than a threshold (DefaultElementsPerSegment)

		if (m - t.begin > DefaultElementsPerSegment) {
		    tasks.push(Task(t.begin, m));
		    more_task = true;
		} else if (m - t.begin > 1)
		    sort(t.begin, m);

		if (t.end - m > DefaultElementsPerSegment) {
		    tasks.push(Task(m + 1, t.end));
		    more_task = true;
		} else if (t.end - m > 1)
		    sort(m + 1, t.end);

		task_in_progress--;
		if (more_task) {
		    cv.notify_one();
		} else if (task_in_progress == 0) {
		    cv.notify_all();
		}
	    }
	}
	return 0;
    }

    template <typename T>
    void QuickSort<T>::sort(Iterator begin, Iterator end)
    {
	typename QuickSort<T>::Iterator m = pivot(begin, end);
	if (m - begin > 1)
	    sort(begin, m);
	if (end - m > 1)
	    sort(m + 1, end);
    }

}	// end of namespace


// Return time elapsed since last call, in seconds (accurate to millisec).

float timeit(void)
{
    using namespace std::chrono;
    static system_clock::time_point tp_last;

    system_clock::time_point now = system_clock::now();
    milliseconds ms = duration_cast<milliseconds>(now - tp_last);
    tp_last = now;

    return ms.count()/1000.0;
}


#ifdef DEBUG
template<typename V>
void dumpq(V& v)
{
    for (auto it = v.begin(); it != v.end(); ++it) {
        cout << *it << ' ';
    }
    cout << endl;
}
#endif



int main(int argc, char* argv[])
{
    try {
	if (argc == 1 || string(argv[1]) == string("-h")) {
	    cout << "usage: " << argv[0]
		 << " data-file [ number-of-threads=4 ]" << endl;
	    return 0;
	}

        cout.setf(std::ios::fixed);
        cout.precision(3);

        std::fstream f(argv[1]);
        if (!f.good())
            throw std::string("Fail to open the file");
	unsigned workers = argc > 2 ? stoi(argv[2]) : 4;

        V v;
	timeit();
	copy(istream_iterator<int>(f),
		istream_iterator<int>(),
		back_inserter(v));
        cout << "load: " << timeit() << endl;
        int size = v.size();
	cout << "    " << size << " items" << endl;

        timeit();
        V v2 = v;
        cout << "duplicate: " << timeit() << endl;

	codex::QuickSort<V> qs(v);
        timeit();
	qs.run(workers);
        cout << "qsort: " << timeit() << endl;

        // validate the result is correct.
	// The input is shuffled from python range(number)
        int i = 0;
        timeit();
        for (auto it = v.begin(); it != v.end(); ++it, ++i) {
            if (i != *it) {
                cerr << "qsort failed" << endl;
                break;
            }
        }
        cout << "validate: " << timeit() << endl;

        timeit();
        sort(v2.begin(), v2.end());
        cout << "std::sort: " << timeit() << endl;
    }
    catch (std::string& e) {
        cerr << e << endl;
    }
    catch (exception& e) {
        cerr << "exception: " << e.what() << endl;
    }
    return 0;
}

