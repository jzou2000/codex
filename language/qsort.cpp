/*
 * Implement quick sort algorithm in C++, used to compare with 
 * different implementations and languages.
 *
 * Shuffled sequence data are generated by shuffle.py.
 *
 * The result on a linux (fedora 18) with 4 cores @2.40G 4GB Mem
 *
 * [jzou@luigi language]$ ./qsort r1m.txt       # 1000000 shuffled data
 * load: 0.18
 * duplicate: 0.00
 * qsort: 0.49
 * validate: 0.03
 * tqsort: 0.28
 * std::sort: 0.51
 * 
 *
 * for -O3 optimization
 *
 * load: 0.16
 * duplicate: 0.00
 * qsort: 0.12
 * validate: 0.00
 * tqsort: 0.12
 * std::sort: 0.10
 * 
 */

#include <exception>
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

#include <sys/time.h>


using namespace std;

float timeit(void)
{
    static struct timeval tv_last = {0, 0};
    struct timeval tv = {0, 0};

    float elapse = 0.0;

    if (0 == gettimeofday(&tv, NULL)) {
        elapse = (tv.tv_sec - tv_last.tv_sec)
                + (tv.tv_usec - tv_last.tv_usec) /1000000.0;
    }
    tv_last = tv;
    return elapse;
}


typedef vector<int> V;

void dumpq(V& v)
{
    for (V::iterator it = v.begin(); it != v.end(); ++it) {
        cout << *it << ' ';
    }
    cout << endl;
}

void qsort(V& v, int start, int end)
{
    if (start >= end)
        return;

    int m = (start + end)/2;
    int pivot = v[m];
    int t;
    if (m < end)
        swap(v[m], v[end]);

    m = start;
    for (int i = start; i < end; i++) {
        if (v[i] < pivot) {
            swap(v[i], v[m]);
            m += 1;
        }
    }
    swap(v[m], v[end]);
    qsort(v, start, m - 1);
    qsort(v, m + 1, end);
}

/* same with qsort, except using template to avoid cost of vector access */
#define tswap(a,b)  {t=a;a=b;b=t;}
template <typename T>
void tqsort(T* v, int start, int end)
{
    if (start >= end)
        return;

    int m = (start + end)/2;
    T pivot = v[m];
    T t;
    if (m < end)
        tswap(v[m], v[end]);

    m = start;
    for (int i = start; i < end; i++) {
        if (v[i] < pivot) {
            tswap(v[i], v[m]);
            m += 1;
        }
    }
    tswap(v[m], v[end]);
    tqsort(v, start, m - 1);
    tqsort(v, m + 1, end);
}


int main(int argc, char* argv[])
{
    try {
        cout.setf(std::ios::fixed);
        cout.precision(2);

        std::fstream f(argv[1]);
        if (!f.good())
            throw std::string("Fail to open the file");

        V v;
        int i;
        timeit();
        while ((f >> i)) {
            v.push_back(i);
        }
        cout << "load: " << timeit() << endl;
        int size = v.size();

        timeit();
        V v2 = v;
        cout << "duplicate: " << timeit() << endl;

        timeit();
        qsort(v, 0, size - 1);
        cout << "qsort: " << timeit() << endl;

        /* validate the result is correct. The input is shuffled
         * from python range(number) */
        i = 0;
        timeit();
        for (V::iterator it = v.begin(); it != v.end(); ++it, ++i) {
            if (i != *it) {
                cerr << "qsort failed" << endl;
                break;
            }
        }
        cout << "validate: " << timeit() << endl;

        int* ti = new int [size];
        for (i = 0; i < size; i++)
            ti[i] = v2[i];
        timeit();
        tqsort(ti, 0, size - 1);
        cout << "tqsort: " << timeit() << endl;
        delete [] ti;

        timeit();
        sort(v2.begin(), v2.end());
        cout << "std::sort: " << timeit() << endl;
    }
    catch (std::string& e) {
        cerr << e << endl;
    }
    catch (exception& e) {
        cerr << "exception: " << e.what() << endl;
    }
    return 0;
}

